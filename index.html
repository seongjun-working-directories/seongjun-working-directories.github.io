<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KBì†í•´ë³´í—˜ - ì‚¬ë‹¤ë¦¬ ê²Œì„</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .buttons {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            justify-content: center;
        }

        button {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-generate {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-generate:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn-reset {
            background: #e0e0e0;
            color: #333;
        }

        .btn-reset:hover {
            background: #d0d0d0;
        }

        .btn-add {
            background: #4CAF50;
            color: white;
        }

        .btn-add:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .ladder-container {
            overflow-x: auto;
            margin-bottom: 20px;
            position: relative;
        }

        canvas {
            display: block;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            cursor: pointer;
        }

        .editable-label {
            position: absolute;
            background: white;
            border: 2px solid #ddd;
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 14px;
            font-weight: 600;
            color: #333;
            cursor: text;
            transition: all 0.2s;
            white-space: nowrap;
            width: 80px;  /* ê³ ì • ë„ˆë¹„ */
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: center;  /* ì¶”ê°€ - ì¤‘ê°„ ì •ë ¬ */
            display: flex;  /* ì¶”ê°€ */
            align-items: center;  /* ì¶”ê°€ - ì„¸ë¡œ ì¤‘ê°„ ì •ë ¬ */
            justify-content: center;  /* ì¶”ê°€ - ê°€ë¡œ ì¤‘ê°„ ì •ë ¬ */
        }

        .editable-label:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .editable-label.editing {
            border-color: #667eea;
            background: #fff;
        }

        .editable-label input {
            border: none;
            outline: none;
            background: transparent;
            font-size: 14px;
            font-weight: 600;
            color: #333;
            width: 80px;  /* ê³ ì • ë„ˆë¹„ */
            max-width: 80px;  /* ìµœëŒ€ ë„ˆë¹„ ì œí•œ */
            text-align: center;
        }

        .result {
            text-align: center;
            font-size: 1.3em;
            color: #667eea;
            font-weight: 600;
            min-height: 30px;
            margin-top: 0px;
        }

        @keyframes bounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .footer {
            text-align: center;
            color: #999;
            margin-top: 20px;
            font-size: 0.9em;
        }

        .label-container {
            position: relative;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ² KBì†í•´ë³´í—˜ ì‹ ì…ì‚¬ì›ë“¤ì˜ ìš´ëª…ì„ ê±´ ì‚¬ë‹¤ë¦¬ ê²Œì„ ğŸ²</h1>
        
        <div class="buttons">
            <button class="btn-add" onclick="addParticipant()">â• ì°¸ê°€ì ì¶”ê°€</button>
            <button class="btn-generate" onclick="generateLadder()">ğŸ² ì‚¬ë‹¤ë¦¬ ìƒì„±</button>
            <button class="btn-reset" onclick="resetGame()">ğŸ”„ ì´ˆê¸°í™”</button>
        </div>

        <div class="ladder-container" id="ladderContainer">
            <div class="label-container" id="labelContainer"></div>
            <canvas id="ladderCanvas"></canvas>
        </div>

        <div class="result" id="result"></div>

        <div class="footer">
            ì°¸ê°€ì/ê²°ê³¼ë¥¼ í´ë¦­í•˜ë©´ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì°¸ê°€ì ì´ë¦„ì„ í´ë¦­í•˜ë©´ ì‚¬ë‹¤ë¦¬ë¥¼ íƒ€ê³  ë‚´ë ¤ê°‘ë‹ˆë‹¤.
        </div>
    </div>

    <script>
        let participants = ['1ë²ˆ', '2ë²ˆ', '3ë²ˆ', '4ë²ˆ', '5ë²ˆ'];
        let prizes = ['ì˜ê´€', 'ê²½ì§€', 'DT', 'ì¼ì', 'ê³„ë³´'];
        let ladderData = [];
        let animating = false;

        const canvas = document.getElementById('ladderCanvas');
        const ctx = canvas.getContext('2d');
        const labelContainer = document.getElementById('labelContainer');

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function addParticipant() {
            participants.push('ìƒˆì°¸ê°€ì');
            prizes.push('ìƒˆê²°ê³¼');
            generateLadder();
        }

        function generateLadder() {
            if (participants.length < 2) {
                alert('ì°¸ê°€ìëŠ” ìµœì†Œ 2ëª… ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤!');
                return;
            }

            document.getElementById('result').textContent = '';

            shuffleArray(participants); // âœ… ì°¸ê°€ì ìˆœì„œ ëœë¤
            shuffleArray(prizes);       // (ì„ íƒ) ê²°ê³¼ë„ ëœë¤ìœ¼ë¡œ í•˜ê³  ì‹¶ìœ¼ë©´ ìœ ì§€

            createLadder();
        }

        function createLadder() {
            const cols = participants.length;
            const rows = Math.max(8, cols * 2);
            
            ladderData = Array(rows).fill(0).map(() => Array(cols - 1).fill(false));

            // 1ë‹¨ê³„: ëœë¤í•˜ê²Œ ê°€ë¡œì„  ë°°ì¹˜ (row 1ë¶€í„° ì‹œì‘, í™•ë¥  ë†’ì„)
            for (let row = 1; row < rows; row++) {  // row = 1ë¶€í„° ì‹œì‘
                for (let col = 0; col < cols - 1; col++) {
                    // 50% í™•ë¥ ë¡œ ìƒì„± ì‹œë„
                    if (Math.random() < 0.5) {
                        const canPlace = 
                            (col === 0 || !ladderData[row][col - 1]) && 
                            (col === cols - 2 || !ladderData[row][col + 1]);
                        
                        if (canPlace) {
                            ladderData[row][col] = true;
                        }
                    }
                }
            }

            // 2ë‹¨ê³„: ê° ì„¸ë¡œì„ ë§ˆë‹¤ ì¶©ë¶„í•œ ê°€ë¡œì„  ë³´ì¥ (êµ¬ê°„ë³„ë¡œ)
            const segmentSize = 3;
            for (let col = 0; col < cols - 1; col++) {
                for (let seg = 0; seg < Math.ceil((rows - 1) / segmentSize); seg++) {
                    const startRow = seg * segmentSize + 1;  // row 1ë¶€í„°
                    const endRow = Math.min(startRow + segmentSize, rows);
                    
                    let hasLine = false;
                    for (let row = startRow; row < endRow; row++) {
                        if (ladderData[row][col]) {
                            hasLine = true;
                            break;
                        }
                    }
                    
                    if (!hasLine) {
                        const availableRows = [];
                        for (let row = startRow; row < endRow; row++) {
                            const canPlace = 
                                (col === 0 || !ladderData[row][col - 1]) && 
                                (col === cols - 2 || !ladderData[row][col + 1]);
                            if (canPlace) {
                                availableRows.push(row);
                            }
                        }
                        
                        if (availableRows.length > 0) {
                            const randomRow = availableRows[Math.floor(Math.random() * availableRows.length)];
                            ladderData[randomRow][col] = true;
                        }
                    }
                }
            }

            drawLadder();
            createEditableLabels();
        }

        function drawLadder() {
            const cols = participants.length;
            const rows = ladderData.length;
            const colWidth = 120;
            const rowHeight = 40;
            const padding = 60;

            canvas.width = cols * colWidth + padding * 2;
            canvas.height = rows * rowHeight + padding * 2 + 80;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;

            for (let i = 0; i < cols; i++) {
                const x = padding + i * colWidth + colWidth / 2;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, padding + rows * rowHeight);
                ctx.stroke();
            }

            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols - 1; c++) {
                    if (ladderData[r][c]) {
                        const x1 = padding + c * colWidth + colWidth / 2;
                        const x2 = padding + (c + 1) * colWidth + colWidth / 2;
                        const y = padding + r * rowHeight;

                        ctx.beginPath();
                        ctx.moveTo(x1, y);
                        ctx.lineTo(x2, y);
                        ctx.stroke();
                    }
                }
            }
        }

        function createEditableLabels() {
            labelContainer.innerHTML = '';
            const cols = participants.length;
            const rows = ladderData.length;
            const colWidth = 120;
            const rowHeight = 40;
            const padding = 60;

            // ìº”ë²„ìŠ¤ì˜ ì‹¤ì œ ìœ„ì¹˜ ê³„ì‚°
            const canvasRect = canvas.getBoundingClientRect();
            const containerRect = labelContainer.parentElement.getBoundingClientRect();
            const canvasOffsetX = canvasRect.left - containerRect.left;
            const canvasOffsetY = canvasRect.top - containerRect.top;


            // ì°¸ê°€ì ë ˆì´ë¸”
            participants.forEach((name, i) => {
                const label = document.createElement('div');
                label.className = 'editable-label';
                label.textContent = name;
                label.style.left = `${canvasOffsetX + padding + i * colWidth + colWidth / 2 - 40}px`;
                label.style.top = `${canvasOffsetY + 10}px`;
                label.onclick = (e) => {
                    e.stopPropagation();
                    if (!animating) {
                        animatePath(i);
                    }
                };
                label.ondblclick = (e) => {
                    e.stopPropagation();
                    makeEditable(label, i, 'participant');
                };
                labelContainer.appendChild(label);
            });

            // ê²°ê³¼ ë ˆì´ë¸”
            prizes.forEach((prize, i) => {
                const label = document.createElement('div');
                label.className = 'editable-label';
                label.textContent = prize;
                label.style.left = `${canvasOffsetX + padding + i * colWidth + colWidth / 2 - 40}px`;
                label.style.top = `${canvasOffsetY + padding + rows * rowHeight + 20}px`;
                label.ondblclick = (e) => {
                    e.stopPropagation();
                    makeEditable(label, i, 'prize');
                };
                labelContainer.appendChild(label);
            });
        }

        function makeEditable(labelElement, index, type) {
            if (labelElement.classList.contains('editing')) return;

            labelElement.classList.add('editing');
            const currentText = labelElement.textContent;
            
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentText;
            input.style.width = '80px';
            input.maxLength = 10;  // ìµœëŒ€ 10ê¸€ìë¡œ ì œí•œ
            
            labelElement.textContent = '';
            labelElement.appendChild(input);
            input.focus();
            input.select();

            const finishEdit = () => {
                const newValue = input.value.trim() || currentText;
                if (type === 'participant') {
                    participants[index] = newValue;
                } else {
                    prizes[index] = newValue;
                }
                labelElement.classList.remove('editing');
                // í…ìŠ¤íŠ¸ê°€ ê¸¸ë©´ ë§ì¤„ì„í‘œ ì ìš©
                labelElement.textContent = newValue;
                labelElement.style.overflow = 'hidden';
                labelElement.style.textOverflow = 'ellipsis';
            };

            input.onblur = finishEdit;
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    finishEdit();
                } else if (e.key === 'Escape') {
                    labelElement.classList.remove('editing');
                    labelElement.textContent = currentText;
                }
            };
        }

        canvas.addEventListener('click', (e) => {
            if (animating || participants.length === 0) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const cols = participants.length;
            const colWidth = 120;
            const padding = 60;

            if (y < padding) {
                for (let i = 0; i < cols; i++) {
                    const centerX = padding + i * colWidth + colWidth / 2;
                    if (Math.abs(x - centerX) < 40) {
                        animatePath(i);
                        break;
                    }
                }
            }
        });

        function animatePath(startCol) {
            animating = true;
            const rows = ladderData.length;
            const colWidth = 120;
            const rowHeight = 40;
            const padding = 60;

            let currentCol = startCol;
            const detailedPath = [];
            const trailPoints = [];

            let tempCol = startCol;
            for (let r = 0; r < rows; r++) {
                const startX = padding + tempCol * colWidth + colWidth / 2;
                const startY = padding + r * rowHeight;
                const endY = padding + (r + 1) * rowHeight;

                let hasHorizontal = false;
                let newCol = tempCol;

                if (tempCol > 0 && ladderData[r][tempCol - 1]) {
                    hasHorizontal = true;
                    newCol = tempCol - 1;
                } else if (tempCol < participants.length - 1 && ladderData[r][tempCol]) {
                    hasHorizontal = true;
                    newCol = tempCol + 1;
                }

                if (hasHorizontal) {
                    detailedPath.push({
                        type: 'vertical',
                        x: startX,
                        y1: startY,
                        y2: startY,
                        col: tempCol,
                        row: r
                    });

                    const endX = padding + newCol * colWidth + colWidth / 2;
                    detailedPath.push({
                        type: 'horizontal',
                        x1: startX,
                        x2: endX,
                        y: startY,
                        col1: tempCol,
                        col2: newCol,
                        row: r
                    });

                    tempCol = newCol;
                }

                detailedPath.push({
                    type: 'vertical',
                    x: padding + tempCol * colWidth + colWidth / 2,
                    y1: startY,
                    y2: endY,
                    col: tempCol,
                    row: r
                });
            }

            let segmentIndex = 0;
            let segmentProgress = 0;

            function animate() {
                if (segmentIndex >= detailedPath.length) {
                    setTimeout(() => {
                        const result = prizes[currentCol];
                        document.getElementById('result').textContent = 
                            `${participants[startCol]} â†’ ${result}`;
                        
                        const resultDiv = document.getElementById('result');
                        resultDiv.style.animation = 'none';
                        setTimeout(() => {
                            resultDiv.style.animation = 'bounce 0.5s ease';
                        }, 10);
                    }, 300);
                    
                    animating = false;
                    return;
                }

                drawLadder();

                const segment = detailedPath[segmentIndex];
                let x, y;

                if (segment.type === 'vertical') {
                    x = segment.x;
                    y = segment.y1 + (segment.y2 - segment.y1) * segmentProgress;
                    currentCol = segment.col;
                } else {
                    x = segment.x1 + (segment.x2 - segment.x1) * segmentProgress;
                    y = segment.y;
                    currentCol = segmentProgress < 0.5 ? segment.col1 : segment.col2;
                }

                segmentProgress += 0.15;
                if (segmentProgress >= 1) {
                    segmentProgress = 0;
                    segmentIndex++;
                }

                trailPoints.push({x, y, alpha: 1});
                if (trailPoints.length > 15) {
                    trailPoints.shift();
                }

                trailPoints.forEach((point, i) => {
                    const alpha = (i / trailPoints.length) * 0.5;
                    ctx.fillStyle = `rgba(76, 175, 80, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                });

                const pulse = Math.sin(Date.now() / 100) * 2 + 10;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, pulse + 5);
                gradient.addColorStop(0, 'rgba(76, 175, 80, 0.8)');
                gradient.addColorStop(0.5, 'rgba(76, 175, 80, 0.4)');
                gradient.addColorStop(1, 'rgba(76, 175, 80, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, pulse + 5, 0, Math.PI * 2);
                ctx.fill();

                const mainGradient = ctx.createRadialGradient(x - 3, y - 3, 0, x, y, pulse);
                mainGradient.addColorStop(0, '#81C784');
                mainGradient.addColorStop(1, '#4CAF50');
                ctx.fillStyle = mainGradient;
                ctx.beginPath();
                ctx.arc(x, y, pulse, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(x - 2, y - 2, pulse * 0.4, 0, Math.PI * 2);
                ctx.fill();

                for (let i = 0; i < segmentIndex; i++) {
                    const seg = detailedPath[i];
                    
                    if (seg.type === 'horizontal') {
                        ctx.strokeStyle = 'rgba(255, 193, 7, 0.8)';
                        ctx.lineWidth = 6;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(seg.x1, seg.y);
                        ctx.lineTo(seg.x2, seg.y);
                        ctx.stroke();
                    } else if (seg.type === 'vertical') {
                        ctx.strokeStyle = 'rgba(255, 193, 7, 0.8)';
                        ctx.lineWidth = 6;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(seg.x, seg.y1);
                        ctx.lineTo(seg.x, seg.y2);
                        ctx.stroke();
                    }
                }

                if (segment.type === 'horizontal') {
                    const partialX = segment.x1 + (segment.x2 - segment.x1) * segmentProgress;
                    ctx.strokeStyle = 'rgba(255, 193, 7, 0.8)';
                    ctx.lineWidth = 6;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(segment.x1, segment.y);
                    ctx.lineTo(partialX, segment.y);
                    ctx.stroke();
                } else if (segment.type === 'vertical') {
                    const partialY = segment.y1 + (segment.y2 - segment.y1) * segmentProgress;
                    ctx.strokeStyle = 'rgba(255, 193, 7, 0.8)';
                    ctx.lineWidth = 6;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(segment.x, segment.y1);
                    ctx.lineTo(segment.x, partialY);
                    ctx.stroke();
                }

                requestAnimationFrame(animate);
            }

            animate();
        }

        function resetGame() {
            participants = ['1ë²ˆ', '2ë²ˆ', '3ë²ˆ', '4ë²ˆ', '5ë²ˆ'];
            prizes = ['ì˜ê´€', 'ê²½ì§€', 'DT', 'ì¼ì', 'ê³„ë³´'];
            ladderData = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            labelContainer.innerHTML = '';
            document.getElementById('result').textContent = '';
            generateLadder();
        }

        generateLadder();

        window.addEventListener('resize', () => {
            if (ladderData.length > 0) {
                drawLadder();
                createEditableLabels();
            }
        });
    </script>
</body>
</html>
